/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | www.openfoam.com
     \\/     M anipulation  |
-------------------------------------------------------------------------------
    Computes the reconstructed distance function (heightDistanceFunction) from a volume-fraction
    field using geometricVoF reconstruction.

\*---------------------------------------------------------------------------*/

#include "heightDistanceFunction.H"
#include "addToRunTimeSelectionTable.H"
#include "ijkZone.H"
#include "PstreamReduceOps.H"

namespace Foam
{
namespace functionObjects
{
    defineTypeNameAndDebug(heightDistanceFunction, 0);
    addToRunTimeSelectionTable(functionObject, heightDistanceFunction, dictionary);
}
}


// * * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * //
bool Foam::functionObjects::heightDistanceFunction::calc()
{
    if (!obr().foundObject<volScalarField>(alphaName_))
    {
        WarningInFunction
            << "alpha field not found: " << alphaName_ << nl;
        return false;
    }

    const volScalarField& alpha =
        obr().lookupObject<volScalarField>(alphaName_);

    const fvMesh& mesh = alpha.mesh();
    //    const ijkZone& IJK = ijkZone::New(mesh);
    const Foam::ijkZone& IJK = Foam::ijkZone::New(mesh);
    
    const label Nx = IJK.Nx();
    const label Ny = IJK.Ny();
    const scalar dz = IJK.dz();

    auto ij = [&](const label i, const label j) -> label { return j*Nx + i; };

    const scalar zMin = IJK.Pmin().z()-(IJK.Pmin().dz()/2.);
    
    // integrate alpha vertically for each column
    scalarField eta(Nx*Ny, 0.0);

    forAll(alpha, celli)
    {
        const Vector<label> g = IJK.ijk3(celli);
        const label i = g.x(), j = g.y();

        if (i < 0 || i >= Nx || j < 0 || j >= Ny)
            continue;

        eta[ij(i,j)] += alpha[celli] * dz;
    }

    Info<<"eta="<<eta<<endl;
    forAll(eta, i)
      {
	reduce(eta[i], sumOp<scalar>());
      }

    // construct the resulting volScalarField
    tmp<volScalarField> tPhi
    (
        new volScalarField
        (
            IOobject
            (
                resultName_,                // from dict, e.g. "heightDistanceFunction"
                mesh.time().timeName(),
                mesh,
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
            mesh,
            dimensionedScalar("zero", dimLength, 0.0)
        )
    );

    volScalarField& phi = tPhi.ref();

    // assign distances: Î·(i,j) - z_c
    forAll(phi, celli)
    {
        const Vector<label> g = IJK.ijk3(celli);
        const label i = g.x(), j = g.y();
        if (i < 0 || i >= Nx || j < 0 || j >= Ny)
            continue;

        phi[celli] = mesh.C()[celli].z()-(eta[ij(i,j)]+zMin);
    }

    //phi.correctBoundaryConditions();

    // store and return true on success
    return store(resultName_, tPhi);
}

// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

Foam::functionObjects::heightDistanceFunction::heightDistanceFunction
(
    const word& name,
    const Time& runTime,
    const dictionary& dict
)
:
  //fvMeshFunctionObject(name, runTime, dict)
  fieldExpression(name, runTime, dict, "alpha.water"),
  //  fieldExpression(name, runTime, dict)
  alphaName_(dict.lookupOrDefault<word>("alpha", "alpha.water")),
  meanWaterLevel_(dict.lookupOrDefault<scalar>("meanWaterLevel", 0.0))
  
{
  setResultName(typeName,"");
  //resultName_ = typeName; 
}


// ************************************************************************* //
