/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | www.openfoam.com
     \\/     M anipulation  |
-------------------------------------------------------------------------------
    Computes the reconstructed distance function (surfaceDistance) from a volume-fraction
    field using geometricVoF reconstruction.

\*---------------------------------------------------------------------------*/

#include "surfaceDistance.H"
#include "addToRunTimeSelectionTable.H"

namespace Foam
{
namespace functionObjects
{
    defineTypeNameAndDebug(surfaceDistance, 0);
    addToRunTimeSelectionTable(functionObject, surfaceDistance, dictionary);
}
}


// * * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * //
bool Foam::functionObjects::surfaceDistance::calc()
{
  if (!obr().foundObject<volScalarField>(alphaName_))
    {
      WarningInFunction << "alpha field not found: " << alphaName_ << nl;
      return false;
    }

  const volScalarField& alpha = obr().lookupObject<volScalarField>(alphaName_);
  
  //    ijkMesh_(ijkZone::New(alpha1.mesh())),
      
    reconstructionSchemes& recon =
      obr().lookupObjectRef<reconstructionSchemes>("reconstructionScheme");

  //recon.reconstruct(false);
  //recon.reconstruct(true);
  
    const volVectorField& interfaceCentres = recon.centre();
    const volVectorField& interfaceNormals = recon.normal();
    zoneDistribute& exchangeFields = zoneDistribute::New(mesh_);


    reconstructedDistanceFunction rdf(mesh_);
    boolList interfaceCells(mesh_.nCells(), false);
    forAll(interfaceCentres,cellI)
    {
        if (mag(interfaceNormals[cellI]) != 0)
        {
            interfaceCells[cellI] = true;
        }
        else
        {
            interfaceCells[cellI] = false;
        }
    }

    // rdf.markCellsNearSurf(recon.interfaceCell(),20);
    rdf.markCellsNearSurf(interfaceCells,20);
    const boolList& nextToInterface= rdf.nextToInterface();
    //boolList nextToInterface(mesh_.nCells(), true);
    //exchangeFields.updateStencil(nextToInterface);
    const Foam::volScalarField& phi=rdf.constructsurfaceDistance(nextToInterface, interfaceCentres, interfaceNormals, exchangeFields, true);

    //    rdf.correctBoundaryConditions(); // update proc patches

    Info<< "Storing surfaceDistance field: min=" << gMin(phi) 
    << " max=" << gMax(phi) << endl;


    //    forAll(phi,iCell)
    // {
    //	if (phi[iCell]==0)
    //	  phi[iCell]=1000.0;
    // }
    
    //    return store(resultName_, phi);
    return store(resultName_, tmp<volScalarField>(new volScalarField(phi)));
}

//bool Foam::functionObjects::surfaceDistance::execute()
//{
    // Typically do nothing here, only act at write time
//  return true;
//}

//bool Foam::functionObjects::surfaceDistance::write()
//{
    // Call calc() to actually compute and write surfaceDistance at output times
//  return calc();
//}

// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

Foam::functionObjects::surfaceDistance::surfaceDistance
(
    const word& name,
    const Time& runTime,
    const dictionary& dict
)
:
  //fvMeshFunctionObject(name, runTime, dict)
    fieldExpression(name, runTime, dict, "alpha.water")
  //  fieldExpression(name, runTime, dict)
    // alphaName_(dict.lookupOrDefault<word>("alpha", "alpha.water"))
{
  setResultName(typeName,"");
  //resultName_ = typeName; 
}


// ************************************************************************* //
