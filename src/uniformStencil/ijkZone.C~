/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2021 OpenCFD Ltd.
     \\/     M anipulation  |
-------------------------------------------------------------------------------
                            | Copyright (C) 2021 Asim Onder
-------------------------------------------------------------------------------

License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

\*---------------------------------------------------------------------------*/

#include "ijkZone.H"
//#include "dummyTransform.H"
//#include "emptyPolyPatch.H"
//#include "processorPolyPatch.H"
//#include "syncTools.H"
//#include "wedgePolyPatch.H"

//#include "globalPoints.H"

// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

namespace Foam
{
    defineTypeNameAndDebug(ijkZone, 0);
}


// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

Foam::ijkZone::ijkZone(const fvMesh& mesh):
  //MeshObject<fvMesh, Foam::TopologicalMeshObject, ijkZone>(mesh),
  mesh_(mesh),
  globalNumbering_(mesh_.nCells()+mesh_.nBoundaryFaces()),
  isEmpty_(false,false,false),
  isCyclic_(false,false,false)
{

  fileName dictPath=mesh_.time().path()/"system/ijkDict";
  if (Pstream::parRun())
    dictPath=mesh_.time().path()/"../system/ijkDict";

  IFstream is(dictPath);
  dictionary ijkDict(is);

  word cellSetName=ijkDict.get<word>("cellSet");
  bool isDomain=true;
  if (cellSetName!="domain")
    isDomain=false;

  const volVectorField& C = mesh_.C();
  const  surfaceVectorField&  Cf = mesh_.Cf();

  cellList cells=mesh_.cells();
  faceList faces=mesh_.faces();
  labelList cellIndices;
  if (!isDomain)
    {
      cellSet cellsToWrite(mesh_, cellSetName);    
      cellIndices=cellsToWrite.toc();
      Info<<"Found the cellSet "<<cellSetName<<" for construction of ijkZone..."<<endl;
    }
  else
    {
      Info<<"Using the whole domain for the construction of ijkZone..."<<endl;
      forAll(C,celli)
	cellIndices.append(celli);
    }

  dx_=0.0;dy_=0.0;dz_=0.0;
  Pmin_=point::uniform(VGREAT);
  Pmax_=point::uniform(-VGREAT);
  if (cellIndices.size()>0)
    {
      const label iCell=cellIndices[0];
      for (int iF=0;iF<6;iF++)
	{	    
	  label f1=cells[iCell][iF];
	  label f2=cells[iCell].opposingFaceLabel(f1,faces);
	  scalar dx=Cf[f1].x()-Cf[f2].x();
	  scalar dy=Cf[f1].y()-Cf[f2].y();
	  scalar dz=Cf[f1].z()-Cf[f2].z();
	  if (dx>dx_)
	    dx_=dx;
	  if (dy>dy_)
	    dy_=dy;
	  if (dz>dz_)
	    dz_=dz;		    
	}

      forAll(cellIndices,celli)
	{
	  const label iCell=cellIndices[celli];
	  const point cc = C[iCell];
	  Pmin_=Foam::min(Pmin_, cc);
	  Pmax_=Foam::max(Pmax_, cc);
	}
    }

  if (Pstream::parRun())
      {
	Foam::reduce(Pmin_, minOp<point>());
	Foam::reduce(Pmax_, maxOp<point>());
	Foam::reduce(dx_, maxOp<scalar>());
	Foam::reduce(dy_, maxOp<scalar>());
	Foam::reduce(dz_, maxOp<scalar>());    
      }

    Info<< "dx= "<<dx_<< ",  dy= "<<dy_<< ",   dz= "<<dz_<<endl;

    Lx_=Pmax_.x()-Pmin_.x();
    Ly_=Pmax_.y()-Pmin_.y();
    Lz_=Pmax_.z()-Pmin_.z();
    Nx_=round(Lx_/dx_+1.0);
    Ny_=round(Ly_/dy_+1.0);
    Nz_=round(Lz_/dz_+1.0);

    Info<<"Pmin="<<Pmin_<<", Pmax="<<Pmax_<<endl;	   
    Info<<"Nx= "<<Nx_<<", Ny= "<<Ny_<<", Nz= "<<Nz_<<endl;

    if (Nx_==1)
      isEmpty.x()=true;
    if (Ny_==1)
      isEmpty.y()=true;
    if (Nz_==1)
      isEmpty.z()=true;
    
    labelList globalIds(Nx_*Ny_*Nz_,-10);
  
    forAll(cellIndices,celli)
      {
	const label iCell=cellIndices[celli];
	const point cc = C[iCell];
	label i=round((cc.x()-Pmin_.x())/dx_);
	label j=round((cc.y()-Pmin_.y())/dy_);
	label k=round((cc.z()-Pmin_.z())/dz_);
	label ijk=i+Nx_*j+Nx_*Ny_*k;
	globalIds[ijk]=globalNumbering_.toGlobal(iCell);
      }
    
    if (Pstream::parRun())
      {
	Foam::reduce(globalIds, maxOp<labelList>());
      }

    globalIds_=globalIds;
    
    //isCyclic?
    forAll(faces,facei)
      {
	if (!mesh_.isInternalFace(facei))
	  {
	    if ((C[mesh_.faceOwner[facei]]<Pmin_ && C[mesh_.faceNeighbour[facei]]<Pmin_) ||
		(C[mesh_.faceOwner[facei]]>Pmax_ && C[mesh_.faceNeighbour[facei]]>Pmax_))
	      {
		continue;
	      }
	    const polyBoundaryMesh& pbm = mesh_.boundaryMesh();
	    	    
	    // Boundary face. Find out which face of which patch
	    const label patchi = pbm.patchID()[facei - mesh_.nInternalFaces()];
  
	    /*if (patchi < 0 || patchi >= pbm.size())
	      {
		FatalErrorInFunction
		  << "Cannot find patch for face " << facei
		  << abort(FatalError);
	      }*/
  
	    // Handle empty patches
	    const polyPatch& pp = pbm[patchi];
	    if (isA<cyclicPolyPatch>(pp))
	      {
		vector transDir=pp.separationVector();
		if (transDir.x()!=0 && transDir.y()==0 transDir.z()==0)
		  isCyclic_.x()=true;
		else if (transDir.y()!=0 && transDir.x()==0 transDir.z()==0)
		  isCyclic_.y()=true;
		else if (transDir.z()!=0 && transDir.x()==0 transDir.y()==0)
		  isCyclic_.z()=true;
		else
		  FatalErrorInFunction
		    << "Cyclic BC found but not aligned with one of the Cartesian coordinates"
		    << abort(FatalError);
	      }
	  }
      }

    if (Pstream::parRun())
      {
	Foam::reduce(isCyclic_.x(), maxOp<bool>());
	Foam::reduce(isCyclic_.y(), maxOp<bool>());
	Foam::reduce(isCyclic_.z(), maxOp<bool>());
      }

}


Foam::List<Foam::scalar> Foam::ijkZone::getStencil(const Map<scalar>& phiIJK,const label celli,const label iMax)
{
  const volVectorField& C = mesh_.C();
  List<scalar> A;

  label NS=2*iMax+1;
  label NxS,Nys,NzS=NS;
  if (isEmpty_.x())
    NxS=1;
  if (isEmpty_.y())
    NyS=1;
  if (isEmpty_.z())
    NzS=1;
  
  label N=NxS*NyS*NzS;
  A.setSize(N,0.0);  
  
  const point cc = C[celli];

  label iP=round((cc.x()-Pmin_.x())/dx_);
  label jP=round((cc.y()-Pmin_.y())/dy_);
  label kP=round((cc.z()-Pmin_.z())/dz_);


  //boundary cells not involved
  if (!isCyclic_.x() and !isEmpty_.x() and (iP+iMax>=Nx_ or iP-iMax<=0))
      FatalErrorInFunction
      << "Stencil is centred at a non-periodic boundary in the x direction!"
      << abort(FatalError);
  if (!isCyclic_.y() and !isEmpty_.y() and (jP+iMax>=Ny_ or jP-iMax<=0))
      FatalErrorInFunction
      << "Stencil is centred at a non-periodic boundary in the y direction!"
      << abort(FatalError);
  if (!isCyclic_.z() and !isEmpty_.z() and (kP+iMax>=Nz_ or kP-iMax<=0))
      FatalErrorInFunction
      << "Stencil is centred at a non-periodic boundary in the z direction!"
      << abort(FatalError);


  int il,jl,kl=0;
      
  if (isEmpty_.x())
    {
      il=0;
      for (int j=-iMax;j<iMax+1;j++)
	{
	  for (int k=-iMax;k<iMax+1;k++)
	    {
	      
	      jl=(jP+j)%Ny_;
	      kl=(kP+k)%Nz_;
	      label ijkG=il+Nx_*jl+Nx_*Ny_*kl;
	      label gblIdx=globalIds_[ijkG];
	      label ijkL=(j+1)+NS*(k+1);
	      A[ijkL]=phiIJK[gblIdx];	
	    }
	}
    }
  else if (isEmpty_.y())
    {
      jl=0;
      for (int i=-iMax;i<iMax+1;i++)
	{
	  for (int k=-iMax;k<iMax+1;k++)
	    {
	      il=(iP+i)%Nx_;
	      kl=(kP+k)%Nz_;
	      label ijkG=il+Nx_*jl+Nx_*Ny_*kl;
	      label gblIdx=globalIds_[ijkG];
	      label ijkL=(i+1)+NS*(k+1);
	      A[ijkL]=phiIJK[gblIdx];	
	    }
	}
    }
  else if (isEmpty_.z())
    {
      kl=0;
      for (int i=-iMax;i<iMax+1;i++)
	{
	  for (int j=-iMax;j<iMax+1;j++)
	    {
	      il=(iP+i)%Nx_;
	      jl=(jP+j)%Ny_;
	      label ijkG=il+Nx_*jl+Nx_*Ny_*kl;
	      label gblIdx=globalIds_[ijkG];
	      label ijkL=(i+1)+NS*(j+1);
	      A[ijkL]=phiIJK[gblIdx];	
	    }
	}
    }
  else
    {
      for (int i=-iMax;i<iMax+1;i++)
	{
	  for (int j=-iMax;j<iMax+1;j++)
	    {
	      for (int k=-iMax;k<iMax+1;k++)
		{
		  label il=(iP+i)%Nx_;
		  label jl=(jP+j)%Ny_;
		  label kl=(kP+k)%Nz_;
		  label ijkG=il+Nx_*jl+Nx_*Ny_*kl;
		  label gblIdx=globalIds_[ijkG];
		  label ijkL=(i+1)+NS*(j+1)+NS*NS*(k+1);
		  A[ijkL]=phiIJK[gblIdx];	
		}
	    }
	}
    }

  return A;
}


// * * * * * * * * * * * * * * * * Selectors  * * * * * * * * * * * * * * //
/*Foam::ijkZone& Foam::ijkZone::New(const fvMesh& mesh)
{
    bool found = mesh.thisDb().foundObject<ijkZone>
    (
        ijkZone::typeName
    ); 
    ijkZone* ptr = nullptr;

    if(found)
    {
        ptr = mesh.thisDb().getObjectPtr<ijkZone>
        (
            ijkZone::typeName
        );

        return *ptr;
    }

    ijkZone* objectPtr = new ijkZone(mesh);

    regIOobject::store(static_cast<ijkZone*>(objectPtr));

    return *objectPtr;
    }*/
 


// ************************************************************************* //
